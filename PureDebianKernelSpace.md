#Подготовка Kernel Space.

# Пересборка ядра #

## Выбор инструментария ##

Пара слов об инструментарии. Ядро — это единственная вещь, которую придётся скомпилировать и здесь есть несколько вариантов (вариантов нет лишь в одном — это делать всё равно придётся, т.к. старое ядро собрано без показа для user-space'а syscall'а accept4() и новый udev от этого стихами заговорит).

Первый вариант — GPL тулчейн WD. Кросс-компиляция по сравнению с нативной будет выполняться куда быстрее, но инструментарий довольно старый (2009 года) - GCC 4.3.

Второй вариант — создание своего тулчейна. Вполне посильно, но не хочется провести несколько дней, отлавливая в нём баги. Для понимания процесса можно обратиться к [Cross Linux From Scratch](http://trac.cross-lfs.org/).

Третий вариант — нативная сборка ядра прямо на MBL в системе-прототипе Debian Wheezy c GCC 4.6.3. Я остановился на нём. Минус здесь — скорость работы, ядро будет собираться примерно час.


## Почему бы не взять свежее ядро? ##
Если сравнить ванильное ядро 2.6.32-11 с тем 2.6.32-11, что предлагает WD по GPL, то видно, что была проведена немалая работа по допиливанию поддежки SoC'а. На MBL можно [запустить](http://qfairy2.blogspot.ru/2013/04/running-on-kernel-390-rc8.html) хоть kernel 3.9.0, но DMA, аппаратный криптодвижок и ряд других функций задействованы не будут. Получится некий сферический Linux, который по производительности будет явно проигрывать заводскому варианту. А втаскивать перечисленные плюшки на актуальное ядро я в одиночку не готов.
Именно поэтому мы возьмём ядро 2.6.32-61, которое минимально отличается от исходного, но в тоже время в нём исправлены многие ошибки.


## Процесс загрузки MBL ##

Это важно для понимания того, с помощью какой нечистой силы три составные части — uBoot, kernel, user-space окружение работают вместе.
После включения устройства на сцену выходит загрузчик uBoot, находящийся в распаянной на плате флешки объёмом 512КБ. Я не стану перечислять все его возможности и регалии, с этим можно ознакомиться [здесь](http://www.denx.de/wiki/U-Boot). Загрузчик считывает с первого раздела SATA-диска сценарий загрузки из файла `/boot/boot.scr`. Вы можете заглянуть в него: он представляет собой plain text с несколькими байтами сигнатуры в самом начале, определяющие для uBoot'а тип скрипта и архитектуру текущего устройства. Не пытайтесь его редактировать вручную, для этого есть отдельная утилита. В Debian-подобных системах её можно поставить из пакета `u-boot-tools`. В сценарии прописана считывания [Device Tree Binary-файла](http://omappedia.org/wiki/Device_Tree) из `/boot/apollo3g.dtb` и ядра Linux из файла `/boot/uImage`. Выполнив эти действия uBoot распаковывает ядро и запускает его с параметрами загрузки, определёнными в том же `/boot/boot.scr` (можете сравнить его содержимое с [логом загрузки](http://mybookworld.wikidot.com/wd-mybook-live-uart)). Далее следует вполне стандартная загрузка ядра с, в том числе, определением места rootfs и запуска init. На этом месте вступает в действие user-space часть — т.е. дальнейшее поведение устройства зависит от того, что вы в качестве дистрибутива на диск установили. Чтобы не редактировать `/boot/boot.scr` вы можете оставить такую же разбивку диска как и в заводской прошивке: sda1 и sda2 по 2ГБ — части RAID1-массива, образующие rootfs, sda3 в 512МБ — swap, sda4 — всё оставшееся место на диске под пользовательские нужды. Я, собственно, этим путём и пошёл, заводская разбивка диска меня вполне устраивает.


## Компиляция ядра ##

В случае нативной компиляции прямо на недостроенной ~~Звезде Смерти~~ Debian Wheezy я подразумеваю, что вы user-space-часть уже подготовили. Поэтому необходимо «провалиться» в неё и выполнить следующие действия.

```
mount -o bind /proc /DataVolume/debinst/proc
mount -o bind /dev /DataVolume/debinst/dev
chroot /DataVolume/debinst
apt-get install build-essential uboot-mkimage ncurses-dev unzip
wget https://www.kernel.org/pub/linux/kernel/v2.6/longterm/v2.6.32/linux-2.6.32.61.tar.xz
xz -dc linux-2.6.32.61.tar.xz|tar -x
cd ./linux-2.6.32.61
```

Перед компиляцией не забудьте накатить на ядро [два патча](http://mbl-common.googlecode.com/svn/kernel_2.6.32-61/): первый добавляет поддержку MBL(D) из GPL ядра + делает доступным для user-space части syscal accept4(), без этого не будет работать новый udev ([Алексей](http://forum.ixbt.com/users.cgi?id=info:%28vkontakte.1403541%29%u0410%u043B%u0435%u043A%u0441%u0435%u0439%20%u0421%u0443%u0445%u0438%u043D%u0438%u043D), спасибо!). Второй - добавляет генерацию файла modules.builtin, требующегося для kmod.

```
patch -p1 -i 001-kernel_2.6.32-61-APM82181-with-accept4.patch
patch -p1 -i 010-kernel_2.6-add-modules.builtin.patch
make distclean
make mrproper
make 44x/apollo_3G_nas_defconfig
make uImage
make modules
make modules_install
```


Всё! Необходимо лишь перенести три файла в будущую систему в папку /boot.

  * готовое ядро `./arch/powerpc/boot/uImage` в будущую систему под именем `/boot/uImage`
  * имеющийся на MBL скрипт `/boot/boot.scr` в будущую систему в `/boot/boot.scr`
  * имеющийся на MBL Dev tree bin `/boot/apollo3g.dtb` в будущую систему в `/boot/apollo3g.dtb`

Ещё опционально забрать с собой модули, в будущей системе они должны будут располагаться в папке /lib/modules.